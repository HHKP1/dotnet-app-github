name: 'App-CI-CD-$(Date:yyyy.MM.dd)$(Rev:.r)'

parameters:
  - name: agentPool
    type: string
    default: 'self-hosted-pool'
    displayName: 'Agent Pool Selection'
    values:
      - self-hosted-pool
      - windows-latest
      - ubuntu-latest

trigger:
  branches:
    include:
      - feature/*
      - bugfix/*
      - hotfix/*
      - develop
      - main
      - release/*
  paths:
    exclude:
      - terraform/*
      - README.md
      - '*.md'

variables:
  - group: tfstate-variables
  - name: isLongLivedBranch
    value: $[ or(eq(variables['Build.SourceBranch'], 'refs/heads/develop'), eq(variables['Build.SourceBranch'], 'refs/heads/main'), startsWith(variables['Build.SourceBranch'], 'refs/heads/release/')) ]
  - name: isDevelopBranch
    value: $[ eq(variables['Build.SourceBranch'], 'refs/heads/develop') ]
  - name: isReleaseBranch
    value: $[ startsWith(variables['Build.SourceBranch'], 'refs/heads/release/') ]
  - name: isMainBranch
    value: $[ eq(variables['Build.SourceBranch'], 'refs/heads/main') ]
  - name: buildConfiguration
    value: 'Release'
  - name: dotNetFramework
    value: 'netcoreapp2.1'
  - name: dotNetVersion
    value: '2.1.x'
  - name: ASPNETCORE_ENVIRONMENT
    value: 'Production'
  - name: versionNumber
    value: $[ coalesce(replace(replace(variables['Build.SourceBranch'], 'refs/heads/release/', ''), 'refs/heads/', ''), '1.0.0') ]

stages:
# ==========================================
# BUILD STAGE - Build .NET Application
# ==========================================
- stage: Build
  displayName: 'Build Application'
  jobs:
  - job: BuildJob
    displayName: 'Build .NET Core Application'
    pool: 
      ${{ if eq(parameters.agentPool, 'self-hosted-pool') }}:
        name: ${{ parameters.agentPool }}
      ${{ else }}:
        vmImage: ${{ parameters.agentPool }}
    steps:
    - task: UseDotNet@2
      displayName: 'Use .NET Core SDK $(dotNetVersion)'
      inputs:
        packageType: 'sdk'
        version: '$(dotNetVersion)'
        installationPath: $(Agent.ToolsDirectory)/dotnet

    # Cross-platform script for commit validation
    - task: PowerShell@2
      displayName: 'Validate Commit Message (Windows)'
      inputs:
        targetType: 'filePath'
        filePath: 'scripts/validate-commit.ps1'
        arguments: '-CommitMessage "$(Build.SourceVersionMessage)"'
      condition: and(succeeded(), ne(variables['Build.SourceVersionMessage'], ''), eq(variables['Agent.OS'], 'Windows_NT'))

    - task: Bash@3
      displayName: 'Validate Commit Message (Linux)'
      inputs:
        targetType: 'filePath'
        filePath: 'scripts/validate-commit.sh'
        arguments: '"$(Build.SourceVersionMessage)"'
      condition: and(succeeded(), ne(variables['Build.SourceVersionMessage'], ''), eq(variables['Agent.OS'], 'Linux'))

    # Cross-platform build number update
    - task: PowerShell@2
      displayName: 'Update Build Number (Windows)'
      inputs:
        targetType: 'filePath'
        filePath: 'scripts/update-build-number-app.ps1'
        arguments: '-BuildId $(Build.BuildId)'
      condition: eq(variables['Agent.OS'], 'Windows_NT')

    - task: Bash@3
      displayName: 'Update Build Number (Linux)'
      inputs:
        targetType: 'filePath'
        filePath: 'scripts/update-build-number-app.sh'
        arguments: '$(Build.BuildId)'
      condition: eq(variables['Agent.OS'], 'Linux')

    - task: DotNetCoreCLI@2
      displayName: 'Restore NuGet Packages'
      inputs:
        command: 'restore'
        projects: '**/*.csproj'
        feedsToUse: 'select'

    - task: DotNetCoreCLI@2
      displayName: 'Build Application'
      inputs:
        command: 'build'
        projects: '**/*.csproj'
        arguments: '--configuration $(buildConfiguration) --no-restore'

    - task: DotNetCoreCLI@2
      displayName: 'Run Unit Tests'
      inputs:
        command: 'test'
        projects: '**/*Tests/*.csproj'
        arguments: '--configuration $(buildConfiguration) --no-build --collect:"XPlat Code Coverage" --logger trx --results-directory $(Common.TestResultsDirectory)'
      continueOnError: false
      condition: succeeded()

    - task: PublishTestResults@2
      displayName: 'Publish Test Results'
      inputs:
        testResultsFormat: 'VSTest'
        testResultsFiles: '**/*.trx'
        searchFolder: '$(Common.TestResultsDirectory)'
        publishRunAttachments: true
      condition: always()

    - task: PublishCodeCoverageResults@1
      displayName: 'Publish Code Coverage'
      inputs:
        codeCoverageTool: 'Cobertura'
        summaryFileLocation: '$(Common.TestResultsDirectory)/**/coverage.cobertura.xml'
      condition: always()

    # Generate database migration script only for long-lived branches
    - task: DotNetCoreCLI@2
      displayName: 'Generate Database Migration Script'
      inputs:
        command: 'custom'
        custom: 'ef'
        arguments: 'migrations script -p DotNetCoreSqlDb.csproj -o $(Build.ArtifactStagingDirectory)/migration-script.sql -i'
        workingDirectory: '$(System.DefaultWorkingDirectory)'
      env:
        ASPNETCORE_ENVIRONMENT: 'Production'
      condition: and(succeeded(), eq(variables.isLongLivedBranch, 'true'))

    - task: DotNetCoreCLI@2
      displayName: 'Publish Application'
      inputs:
        command: 'publish'
        publishWebProjects: false
        projects: 'DotNetCoreSqlDb.csproj'
        arguments: '--configuration $(buildConfiguration) --output $(Build.ArtifactStagingDirectory)/app --no-build'
        modifyOutputPath: false
        zipAfterPublish: false
      condition: and(succeeded(), eq(variables.isLongLivedBranch, 'true'))

    - task: ArchiveFiles@2
      displayName: 'Archive Application Files'
      inputs:
        rootFolderOrFile: '$(Build.ArtifactStagingDirectory)/app'
        includeRootFolder: false
        archiveType: 'zip'
        archiveFile: '$(Build.ArtifactStagingDirectory)/app.$(Build.BuildNumber).zip'
        replaceExistingArchive: true
      condition: and(succeeded(), eq(variables.isLongLivedBranch, 'true'))

    - task: PublishBuildArtifacts@1
      displayName: 'Publish Application Artifact'
      inputs:
        pathToPublish: '$(Build.ArtifactStagingDirectory)/app.$(Build.BuildNumber).zip'
        artifactName: 'application'
        publishLocation: 'Container'
      condition: and(succeeded(), eq(variables.isLongLivedBranch, 'true'))

    - task: PublishBuildArtifacts@1
      displayName: 'Publish Database Migration Script'
      inputs:
        pathToPublish: '$(Build.ArtifactStagingDirectory)/migration-script.sql'
        artifactName: 'database-migration'
        publishLocation: 'Container'
      condition: and(succeeded(), eq(variables.isLongLivedBranch, 'true'))

# ==========================================
# DEV ENVIRONMENT DEPLOYMENT (from develop branch)
# ==========================================
- stage: Deploy_DEV
  displayName: 'Deploy to DEV'
  dependsOn: Build
  condition: and(succeeded(), eq(variables.isDevelopBranch, 'true'))
  jobs:
  - deployment: DeployToDev
    displayName: 'Deploy Application to DEV'
    environment: DEV
    pool: 
      ${{ if eq(parameters.agentPool, 'self-hosted-pool') }}:
        name: ${{ parameters.agentPool }}
      ${{ else }}:
        vmImage: ${{ parameters.agentPool }}
    variables:
      - group: dev-variables
    strategy:
      runOnce:
        deploy:
          steps:
          - template: templates/app-deploy-template.yml
            parameters:
              environmentName: 'dev'
              serviceConnection: 'azure-subscription'
              agentPool: ${{ parameters.agentPool }}
              deployToSlot: false
              performHealthCheck: true

# ==========================================
# QA ENVIRONMENT DEPLOYMENT (from release/* branches)
# ==========================================
- stage: Deploy_QA
  displayName: 'Deploy to QA'
  dependsOn: Build
  condition: and(succeeded(), eq(variables.isReleaseBranch, 'true'))
  jobs:
  - deployment: DeployToQa
    displayName: 'Deploy Application to QA'
    environment: QA
    pool: 
      ${{ if eq(parameters.agentPool, 'self-hosted-pool') }}:
        name: ${{ parameters.agentPool }}
      ${{ else }}:
        vmImage: ${{ parameters.agentPool }}
    variables:
      - group: qa-variables
    strategy:
      runOnce:
        deploy:
          steps:
          - template: templates/app-deploy-template.yml
            parameters:
              environmentName: 'qa'
              serviceConnection: 'azure-subscription'
              agentPool: ${{ parameters.agentPool }}
              deployToSlot: false
              performHealthCheck: true

# ==========================================
# UAT ENVIRONMENT DEPLOYMENT (from release/* branches, requires QA approval)
# ==========================================
- stage: Deploy_UAT
  displayName: 'Deploy to UAT'
  dependsOn: Deploy_QA
  condition: and(succeeded(), eq(variables.isReleaseBranch, 'true'))
  jobs:
  - deployment: DeployToUat
    displayName: 'Deploy Application to UAT'
    environment: UAT
    pool: 
      ${{ if eq(parameters.agentPool, 'self-hosted-pool') }}:
        name: ${{ parameters.agentPool }}
      ${{ else }}:
        vmImage: ${{ parameters.agentPool }}
    variables:
      - group: uat-variables
    strategy:
      runOnce:
        deploy:
          steps:
          - template: templates/app-deploy-template.yml
            parameters:
              environmentName: 'uat'
              serviceConnection: 'azure-subscription'
              agentPool: ${{ parameters.agentPool }}
              deployToSlot: false
              performHealthCheck: true

# ==========================================
# PROD ENVIRONMENT - STAGING SLOT (from main branch)
# ==========================================
- stage: Deploy_PROD_Staging
  displayName: 'Deploy to PROD Staging Slot'
  dependsOn: Build
  condition: and(succeeded(), eq(variables.isMainBranch, 'true'))
  jobs:
  - deployment: DeployToProdStaging
    displayName: 'Deploy Application to PROD Staging Slot'
    environment: PROD
    pool: 
      ${{ if eq(parameters.agentPool, 'self-hosted-pool') }}:
        name: ${{ parameters.agentPool }}
      ${{ else }}:
        vmImage: ${{ parameters.agentPool }}
    variables:
      - group: prod-variables
    strategy:
      runOnce:
        deploy:
          steps:
          - template: templates/app-deploy-template.yml
            parameters:
              environmentName: 'prod'
              serviceConnection: 'azure-subscription'
              agentPool: ${{ parameters.agentPool }}
              deployToSlot: true
              slotName: 'staging'
              performHealthCheck: true

# ==========================================
# PROD ENVIRONMENT - SLOT SWAP (from main branch)
# ==========================================
- stage: Swap_PROD_Slots
  displayName: 'Swap PROD Slots'
  dependsOn: Deploy_PROD_Staging
  condition: and(succeeded(), eq(variables.isMainBranch, 'true'))
  jobs:
  - deployment: SwapProdSlots
    displayName: 'Swap Staging to Production'
    environment: PROD-SWAP
    pool: 
      ${{ if eq(parameters.agentPool, 'self-hosted-pool') }}:
        name: ${{ parameters.agentPool }}
      ${{ else }}:
        vmImage: ${{ parameters.agentPool }}
    variables:
      - group: prod-variables
    strategy:
      runOnce:
        deploy:
          steps:
          - task: AzureAppServiceManage@0
            displayName: 'Swap Staging to Production'
            inputs:
              azureSubscription: 'azure-subscription'
              action: 'Swap Slots'
              webAppName: 'app-$(RESOURCE_NAME_PREFIX)-$(LOCATION)-prod'
              resourceGroupName: 'rg-$(RESOURCE_NAME_PREFIX)-$(LOCATION)-prod'
              sourceSlot: 'staging'
              targetSlot: 'production'

          - task: PowerShell@2
            displayName: 'Verify Production Deployment'
            inputs:
              targetType: 'inline'
              script: |
                $prodUrl = "https://app-$(RESOURCE_NAME_PREFIX)-$(LOCATION)-prod.azurewebsites.net"
                $stagingUrl = "https://app-$(RESOURCE_NAME_PREFIX)-$(LOCATION)-prod-staging.azurewebsites.net"
                
                Write-Host "🔄 Slot swap completed successfully!" -ForegroundColor Green
                Write-Host ""
                Write-Host "🎯 Final Deployment URLs:" -ForegroundColor Cyan
                Write-Host "🔵 Production URL: $prodUrl" -ForegroundColor Blue
                Write-Host "🟢 Staging URL: $stagingUrl" -ForegroundColor Green
                Write-Host ""
                
                # Basic health check
                try {
                    Write-Host "🔍 Performing health check on production..." -ForegroundColor Yellow
                    $response = Invoke-WebRequest -Uri $prodUrl -Method GET -TimeoutSec 30 -UseBasicParsing
                    if ($response.StatusCode -eq 200) {
                        Write-Host "✅ Production deployment verified successfully!" -ForegroundColor Green
                        Write-Host "📊 Status Code: $($response.StatusCode)" -ForegroundColor Green
                    } else {
                        Write-Host "⚠️ Production returned status: $($response.StatusCode)" -ForegroundColor Yellow
                    }
                } catch {
                    Write-Host "❌ Failed to verify production deployment: $($_.Exception.Message)" -ForegroundColor Red
                    Write-Host "🔧 Please manually verify the deployment using the URLs above" -ForegroundColor Yellow
                }
                
                Write-Host ""
                Write-Host "📝 Share these URLs with your trainer:" -ForegroundColor Magenta
                Write-Host "   Production: $prodUrl" -ForegroundColor White
                Write-Host "   Staging: $stagingUrl" -ForegroundColor White