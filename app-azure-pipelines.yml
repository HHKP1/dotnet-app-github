name: 'App-CI-CD-$(Date:yyyy.MM.dd)$(Rev:.r)'

parameters:
  - name: agentPool
    type: string
    default: 'self-hosted-pool'
    displayName: 'Agent Pool Selection'
    values:
      - self-hosted-pool
      - windows-latest
      - ubuntu-latest

trigger:
  branches:
    include:
      - feature/*
      - bugfix/*
      - hotfix/*
      - develop
      - main
      - release/*
  paths:
    exclude:
      - terraform/*
      - README.md
      - '*.md'

variables:
  - group: prod-variables
  - name: isLongLivedBranch
    value: $[ or(eq(variables['Build.SourceBranch'], 'refs/heads/develop'), eq(variables['Build.SourceBranch'], 'refs/heads/main'), startsWith(variables['Build.SourceBranch'], 'refs/heads/release/')) ]
  - name: buildConfiguration
    value: 'Release'
  - name: dotNetFramework
    value: 'netcoreapp2.1'
  - name: dotNetVersion
    value: '2.1.x'
  - name: ASPNETCORE_ENVIRONMENT
    value: 'Production'
  - name: versionNumber
    value: $[ coalesce(replace(replace(variables['Build.SourceBranch'], 'refs/heads/release/', ''), 'refs/heads/', ''), '1.0.0') ]

stages:
# ==========================================
# BUILD STAGE - Build .NET Application
# ==========================================
- stage: Build
  displayName: 'Build Application'
  jobs:
  - job: BuildJob
    displayName: 'Build .NET Core Application'
    pool: 
      ${{ if eq(parameters.agentPool, 'self-hosted-pool') }}:
        name: ${{ parameters.agentPool }}
      ${{ else }}:
        vmImage: ${{ parameters.agentPool }}
    steps:
    - task: UseDotNet@2
      displayName: 'Use .NET Core SDK $(dotNetVersion)'
      inputs:
        packageType: 'sdk'
        version: '$(dotNetVersion)'
        installationPath: $(Agent.ToolsDirectory)/dotnet

    # Cross-platform script for commit validation
    - task: PowerShell@2
      displayName: 'Validate Commit Message (Windows)'
      inputs:
        targetType: 'filePath'
        filePath: 'scripts/validate-commit.ps1'
        arguments: '-CommitMessage "$(Build.SourceVersionMessage)"'
      condition: and(succeeded(), ne(variables['Build.SourceVersionMessage'], ''), eq(variables['Agent.OS'], 'Windows_NT'))

    - task: Bash@3
      displayName: 'Validate Commit Message (Linux)'
      inputs:
        targetType: 'filePath'
        filePath: 'scripts/validate-commit.sh'
        arguments: '"$(Build.SourceVersionMessage)"'
      condition: and(succeeded(), ne(variables['Build.SourceVersionMessage'], ''), eq(variables['Agent.OS'], 'Linux'))

    # Cross-platform build number update
    - task: PowerShell@2
      displayName: 'Update Build Number (Windows)'
      inputs:
        targetType: 'filePath'
        filePath: 'scripts/update-build-number-app.ps1'
        arguments: '-BuildId $(Build.BuildId)'
      condition: eq(variables['Agent.OS'], 'Windows_NT')

    - task: Bash@3
      displayName: 'Update Build Number (Linux)'
      inputs:
        targetType: 'filePath'
        filePath: 'scripts/update-build-number-app.sh'
        arguments: '$(Build.BuildId)'
      condition: eq(variables['Agent.OS'], 'Linux')

    - task: DotNetCoreCLI@2
      displayName: 'Restore NuGet Packages'
      inputs:
        command: 'restore'
        projects: '**/*.csproj'
        feedsToUse: 'select'

    - task: DotNetCoreCLI@2
      displayName: 'Build Application'
      inputs:
        command: 'build'
        projects: '**/*.csproj'
        arguments: '--configuration $(buildConfiguration) --no-restore'

    - task: DotNetCoreCLI@2
      displayName: 'Run Unit Tests'
      inputs:
        command: 'test'
        projects: '**/*Tests/*.csproj'
        arguments: '--configuration $(buildConfiguration) --no-build --collect:"XPlat Code Coverage" --logger trx --results-directory $(Common.TestResultsDirectory)'
      continueOnError: false
      condition: succeeded()

    - task: PublishTestResults@2
      displayName: 'Publish Test Results'
      inputs:
        testResultsFormat: 'VSTest'
        testResultsFiles: '**/*.trx'
        searchFolder: '$(Common.TestResultsDirectory)'
        publishRunAttachments: true
      condition: always()

    - task: PublishCodeCoverageResults@1
      displayName: 'Publish Code Coverage'
      inputs:
        codeCoverageTool: 'Cobertura'
        summaryFileLocation: '$(Common.TestResultsDirectory)/**/coverage.cobertura.xml'
      condition: always()

    # Cross-platform EF migrations script generation
    - task: DotNetCoreCLI@2
      displayName: 'Generate Database Migration Script'
      inputs:
        command: 'custom'
        custom: 'ef'
        arguments: 'migrations script -p DotNetCoreSqlDb.csproj -o $(Build.ArtifactStagingDirectory)/migration-script.sql -i'
        workingDirectory: '$(System.DefaultWorkingDirectory)'
      env:
        ASPNETCORE_ENVIRONMENT: 'Production'
      condition: and(succeeded(), eq(variables.isLongLivedBranch, 'true'))

    - task: DotNetCoreCLI@2
      displayName: 'Publish Application'
      inputs:
        command: 'publish'
        publishWebProjects: true
        arguments: '--configuration $(buildConfiguration) --output $(Build.ArtifactStagingDirectory)/app --no-build'
        zipAfterPublish: false
      condition: and(succeeded(), eq(variables.isLongLivedBranch, 'true'))

    - task: ArchiveFiles@2
      displayName: 'Archive Application Files'
      inputs:
        rootFolderOrFile: '$(Build.ArtifactStagingDirectory)/app'
        includeRootFolder: false
        archiveType: 'zip'
        archiveFile: '$(Build.ArtifactStagingDirectory)/app.$(Build.BuildNumber).zip'
        replaceExistingArchive: true
      condition: and(succeeded(), eq(variables.isLongLivedBranch, 'true'))

    - task: PublishBuildArtifacts@1
      displayName: 'Publish Application Artifact'
      inputs:
        pathToPublish: '$(Build.ArtifactStagingDirectory)/app.$(Build.BuildNumber).zip'
        artifactName: 'application'
        publishLocation: 'Container'
      condition: and(succeeded(), eq(variables.isLongLivedBranch, 'true'))

    - task: PublishBuildArtifacts@1
      displayName: 'Publish Database Migration Script'
      inputs:
        pathToPublish: '$(Build.ArtifactStagingDirectory)/migration-script.sql'
        artifactName: 'database-migration'
        publishLocation: 'Container'
      condition: and(succeeded(), eq(variables.isLongLivedBranch, 'true'))

# ==========================================
# DEPLOY TO STAGING SLOT
# ==========================================
- stage: Deploy_Staging
  displayName: 'Deploy to Staging Slot'
  dependsOn: Build
  condition: and(succeeded(), eq(variables.isLongLivedBranch, 'true'))
  jobs:
  - deployment: DeployToStaging
    displayName: 'Deploy Application to Staging Slot'
    environment: PROD-STAGING
    pool: 
      ${{ if eq(parameters.agentPool, 'self-hosted-pool') }}:
        name: ${{ parameters.agentPool }}
      ${{ else }}:
        vmImage: ${{ parameters.agentPool }}
    variables:
      - group: prod-variables
    strategy:
      runOnce:
        deploy:
          steps:
          - task: DownloadBuildArtifacts@1
            displayName: 'Download Application Artifacts'
            inputs:
              artifactName: 'application'
              downloadPath: '$(Pipeline.Workspace)'

          - task: DownloadBuildArtifacts@1
            displayName: 'Download Database Migration Artifacts'
            inputs:
              artifactName: 'database-migration'
              downloadPath: '$(Pipeline.Workspace)'

          - task: ExtractFiles@1
            displayName: 'Extract Application Files'
            inputs:
              archiveFilePatterns: '$(Pipeline.Workspace)/application/app.$(Build.BuildNumber).zip'
              destinationFolder: '$(Pipeline.Workspace)/extracted-app'

          # Cross-platform database update
          - task: SqlAzureDacpacDeployment@1
            displayName: 'Update Database Schema'
            inputs:
              azureSubscription: 'azure-subscription'
              authenticationType: 'servicePrincipal'
              serverName: 'sql-$(RESOURCE_NAME_PREFIX)-$(LOCATION)-prod.database.windows.net'
              databaseName: 'sqldb-$(RESOURCE_NAME_PREFIX)-$(LOCATION)-prod'
              deployType: 'SqlTask'
              sqlFile: '$(Pipeline.Workspace)/database-migration/migration-script.sql'
              sqlUsername: '$(SQL_SERVER_ADMINISTRATOR_LOGIN)'
              sqlPassword: '$(SQL_SERVER_ADMINISTRATOR_PASSWORD)'

          - task: AzureWebApp@1
            displayName: 'Deploy to Staging Slot'
            inputs:
              azureSubscription: 'azure-subscription'
              appName: 'app-$(RESOURCE_NAME_PREFIX)-$(LOCATION)-prod'
              deployToSlotOrASE: true
              resourceGroupName: 'rg-$(RESOURCE_NAME_PREFIX)-$(LOCATION)-prod'
              slotName: 'staging'
              package: '$(Pipeline.Workspace)/extracted-app'
              appSettings: |-
                ASPNETCORE_ENVIRONMENT=$(ASPNETCORE_ENVIRONMENT) Version=$(Build.BuildNumber)

          # Cross-platform verification script
          - task: PowerShell@2
            displayName: 'Display Deployment URLs (Windows)'
            inputs:
              targetType: 'inline'
              script: |
                $prodUrl = "https://app-$(RESOURCE_NAME_PREFIX)-$(LOCATION)-prod.azurewebsites.net"
                $stagingUrl = "https://app-$(RESOURCE_NAME_PREFIX)-$(LOCATION)-prod-staging.azurewebsites.net"
                
                Write-Host "✅ Application deployed to staging slot successfully!" -ForegroundColor Green
                Write-Host ""
                Write-Host "🔵 Production URL: $prodUrl" -ForegroundColor Blue
                Write-Host "🟢 Staging URL: $stagingUrl" -ForegroundColor Green
                Write-Host ""
                Write-Host "📋 Next step: Review staging deployment, then proceed to slot swap" -ForegroundColor Yellow
            condition: eq(variables['Agent.OS'], 'Windows_NT')

          - task: Bash@3
            displayName: 'Display Deployment URLs (Linux)'
            inputs:
              targetType: 'inline'
              script: |
                prodUrl="https://app-$(RESOURCE_NAME_PREFIX)-$(LOCATION)-prod.azurewebsites.net"
                stagingUrl="https://app-$(RESOURCE_NAME_PREFIX)-$(LOCATION)-prod-staging.azurewebsites.net"
                
                echo "✅ Application deployed to staging slot successfully!"
                echo ""
                echo "🔵 Production URL: $prodUrl"
                echo "🟢 Staging URL: $stagingUrl"
                echo ""
                echo "📋 Next step: Review staging deployment, then proceed to slot swap"
            condition: eq(variables['Agent.OS'], 'Linux')

# ==========================================
# SWAP PRODUCTION SLOTS
# ==========================================
- stage: Swap_Slots
  displayName: 'Swap Production Slots'
  dependsOn: Deploy_Staging
  condition: and(succeeded(), eq(variables.isLongLivedBranch, 'true'))
  jobs:
  - deployment: SwapSlots
    displayName: 'Swap Staging to Production'
    environment: PROD-SWAP
    pool: 
      ${{ if eq(parameters.agentPool, 'self-hosted-pool') }}:
        name: ${{ parameters.agentPool }}
      ${{ else }}:
        vmImage: ${{ parameters.agentPool }}
    variables:
      - group: prod-variables
    strategy:
      runOnce:
        deploy:
          steps:
          - task: AzureAppServiceManage@0
            displayName: 'Swap Staging to Production'
            inputs:
              azureSubscription: 'azure-subscription'
              action: 'Swap Slots'
              webAppName: 'app-$(RESOURCE_NAME_PREFIX)-$(LOCATION)-prod'
              resourceGroupName: 'rg-$(RESOURCE_NAME_PREFIX)-$(LOCATION)-prod'
              sourceSlot: 'staging'
              targetSlot: 'production'

          # Cross-platform verification
          - task: PowerShell@2
            displayName: 'Verify Deployment and Display URLs (Windows)'
            inputs:
              targetType: 'inline'
              script: |
                $prodUrl = "https://app-$(RESOURCE_NAME_PREFIX)-$(LOCATION)-prod.azurewebsites.net"
                $stagingUrl = "https://app-$(RESOURCE_NAME_PREFIX)-$(LOCATION)-prod-staging.azurewebsites.net"
                
                Write-Host "🔄 Slot swap completed successfully!" -ForegroundColor Green
                Write-Host ""
                Write-Host "🎯 Final Deployment URLs:" -ForegroundColor Cyan
                Write-Host "🔵 Production URL: $prodUrl" -ForegroundColor Blue
                Write-Host "🟢 Staging URL: $stagingUrl" -ForegroundColor Green
                Write-Host ""
                
                # Basic health check
                try {
                    Write-Host "🔍 Performing health check on production..." -ForegroundColor Yellow
                    $response = Invoke-WebRequest -Uri $prodUrl -Method GET -TimeoutSec 30 -UseBasicParsing
                    if ($response.StatusCode -eq 200) {
                        Write-Host "✅ Production deployment verified successfully!" -ForegroundColor Green
                        Write-Host "📊 Status Code: $($response.StatusCode)" -ForegroundColor Green
                    } else {
                        Write-Host "⚠️ Production returned status: $($response.StatusCode)" -ForegroundColor Yellow
                    }
                } catch {
                    Write-Host "❌ Failed to verify production deployment: $($_.Exception.Message)" -ForegroundColor Red
                    Write-Host "🔧 Please manually verify the deployment using the URLs above" -ForegroundColor Yellow
                }
                
                Write-Host ""
                Write-Host "📝 Share these URLs with your trainer:" -ForegroundColor Magenta
                Write-Host "   Production: $prodUrl" -ForegroundColor White
                Write-Host "   Staging: $stagingUrl" -ForegroundColor White
            condition: eq(variables['Agent.OS'], 'Windows_NT')

          - task: Bash@3
            displayName: 'Verify Deployment and Display URLs (Linux)'
            inputs:
              targetType: 'inline'
              script: |
                prodUrl="https://app-$(RESOURCE_NAME_PREFIX)-$(LOCATION)-prod.azurewebsites.net"
                stagingUrl="https://app-$(RESOURCE_NAME_PREFIX)-$(LOCATION)-prod-staging.azurewebsites.net"
                
                echo "🔄 Slot swap completed successfully!"
                echo ""
                echo "🎯 Final Deployment URLs:"
                echo "🔵 Production URL: $prodUrl"
                echo "🟢 Staging URL: $stagingUrl"
                echo ""
                
                # Basic health check
                echo "🔍 Performing health check on production..."
                if curl -f -s -o /dev/null -w "%{http_code}" "$prodUrl" | grep -q "200"; then
                    echo "✅ Production deployment verified successfully!"
                else
                    echo "⚠️ Production health check failed - please verify manually"
                fi
                
                echo ""
                echo "📝 Share these URLs with your trainer:"
                echo "   Production: $prodUrl"
                echo "   Staging: $stagingUrl"
            condition: eq(variables['Agent.OS'], 'Linux')